In computer programming, an "entry point" is where the first instructions in a program are executed, and where the program has access to command line arguments.

To start a program's execution, the loader or operating system passes control to its entry point. (During booting, the operating system itself is the program). This marks the transition from load time (and dynamic link time, if present) to run time.

For some operating systems and programming languages, the entry point is in a runtime library, a set of support functions for the language. The library code initializes the program and then passes control to the program proper. In other cases, the program may initialize the runtime library itself. 

In simple systems, execution begins at the first statement, which is common in interpreted languages, simple executable formats, and boot loaders. In other cases, the entry point is at some other known memory address which can be an absolute address or relative address (offset).

Alternatively, execution of a program can begin at a named point, either with a conventional name defined by the programming language or operating system or at a caller-specified name. In many C-family languages, this is a function named <code>main</code>; as a result, the entry point is often known as the "main function".

In JVM languages such as Java the entry point is a static method named <code>main</code>; in CLI languages such as C# the entry point is a static method named <code>Main</code>.
== Usage ==
Entry points apply both to source code and to executable files. However, in day-to-day software development, programmers specify the entry points only in source code, which makes them much better known. Entry points in executable files depend on the application binary interface (ABI) of the actual operating system, and are generated by the compiler or linker (if not fixed by the ABI). Other linked object files may also have entry points, which are used later by the linker when generating entry points of an executable file.

Entry points are capable of passing on command arguments, variables, or other information as a local variable used by the <code>Main()</code> method. This way, specific options may be set upon execution of the program, and then interpreted by the program. Many programs use this as an alternative way to configure different settings, or perform a set variety of actions using a single program.

=== Contemporary ===
In most of today's popular programming languages and operating systems, a computer program usually only has a single "entry point".

In C, C++, D, Rust and Kotlin programs this is a function named <code>main</code>; in Java it is a static method named <code>main</code> (although the class must be specified at the invocation time), and in C# it is a static method named <code>Main</code>.

In many major operating systems, the standard executable format has a single entry point. In the Executable and Linkable Format (ELF), used in Unix and Unix-like systems such as Linux, the entry point is specified in the <code>e_entry</code> field of the ELF header. In the GNU Compiler Collection (gcc), the entry point used by the linker is the <code>_start</code> symbol. Similarly, in the Portable Executable format, used in Microsoft Windows, the entry point is specified by the <code>AddressOfEntryPoint</code> field, which is inherited from COFF. In COM files, the entry point is at the fixed offset of 0100h.

One exception to the single-entry-point paradigm is Android.  Android applications do not have a single entry point there is no special <code>main</code> function. Instead, they have "essential components" (activities and services) which the system can load and run as needed.

An occasionally used technique is the fat binary, which consists of several executables for different targets packaged in a single file. Most commonly, this is implemented by a single overall entry point, which is compatible with all targets and branches to the target-specific entry point. Alternative techniques include storing separate executables in separate forks, each with its own entry point, which is then selected by the operating system.

=== Historical ===
Historically, and in some contemporary legacy systems, such as VMS and OS/400, computer programs have a multitude of "entry points", each corresponding to the different functionalities of the program. The usual way to denote entry points, as used system-wide in VMS and in PL/I and MACRO programs, is to append them at the end of the name of the executable image, delimited by a dollar sign ($), e.g. <code>directory.exe$make</code>.

The Apple I computer also used this to some degree. For example, an alternative entry point in Apple I's BASIC would keep the BASIC program useful when the reset button was accidentally pushed.

== Exit point ==
In general, programs can exit at any time by returning to the operating system or crashing. Programs in interpreted languages return control to the interpreter, but programs in compiled languages must return to the operating system, otherwise the processor will simply continue executing beyond the end of the program, resulting in undefined behavior.

Usually, there is not a single exit point specified in a program. However, in other cases runtimes ensure that programs always terminate in a structured way via a single exit point, which is guaranteed unless the runtime itself crashes; this allows cleanup code to be run, such as <code>atexit</code> handlers. This can be done by either requiring that programs terminate by returning from the main function, by calling a specific exit function, or by the runtime catching exceptions or operating system signals.

==Programming languages==
In many programming languages, the <code>main</code> function is where a program starts its execution. It enables high-level organization of the program's functionality, and typically has access to the command arguments given to the program when it was executed.

The main function is generally the first programmer-written function that runs when a program starts, and is invoked directly from the system-specific initialization contained in the runtime environment (crt0 or equivalent). However, some languages can execute user-written functions before main runs, such as the constructors of C++ global objects.

In other languages, notably many interpreted languages, execution begins at the first statement in the program.

A non-exhaustive list of programming languages follows, describing their way of defining the main entry point:

===APL===
In APL, when a workspace is loaded, the contents of "quad LX" (latent expression) variable is interpreted as an APL expression and executed.

===C and C++===
In C and C++, the function prototype of the main function looks like one of the following:

<source lang="c">
int main(void);
int main();

int main(int argc, char **argv);
int main(int argc, char *argv[]);
int main(int argc, char **argv, char **env);

// more specifically in C
// NOT according to the ISO C standard 5.1.2.2.1
// BUT in embedded programming depending on the µC, this form is also used
void main (void);
</source>

The parameters <code>argc</code>, "argument count", and <code>argv</code>, "argument vector", respectively give the number and values of the program's command-line arguments. The names of <code>argc</code> and <code>argv</code> may be any valid identifier in C, but it is common convention to use these names. In C++, the names are to be taken literally, and the "void" in the parameter list is to be omitted, if strict conformance is desired. Other platform-dependent formats are also allowed by the C and C++ standards, except that in C++ the return type must always be <code>int</code>; for example, Unix (though not POSIX.1) and Windows have a third argument giving the program's environment, otherwise accessible through <code>getenv</code> in <code>stdlib.h</code>:

<source lang="c">
int main(int argc, char **argv, char **envp);
</source>

Darwin-based operating systems, such as macOS, have a fourth parameter containing arbitrary OS-supplied information, such as the path to the executing binary:

<source lang="c">
int main(int argc, char **argv, char **envp, char **apple);
</source>

The value returned from the main function becomes the exit status of the process, though the C standard only ascribes specific meaning to two values: <code>EXIT_SUCCESS</code> (traditionally 0) and <code>EXIT_FAILURE</code>. The meaning of other possible return values is implementation-defined. In case a return value is not defined by the programmer, an implicit <code>return 0;</code> at the end of the <code>main()</code> function is inserted by the compiler; this behavior is required by the C++ standard.

It is guaranteed that <code>argc</code> is non-negative and that <code>argv[argc]</code> is a null pointer. By convention, the command-line arguments specified by <code>argc</code> and <code>argv</code> include the name of the program as the first element if <code>argc</code> is greater than 0; if a user types a command of "<code>rm file</code>", the shell will initialise the <code>rm</code> process with <code>argc = 2</code> and <code>argv = {"rm", "file", NULL}</code>.  As <code>argv[0]</code> is the name that processes appear under in <code>ps</code>, <code>top</code> etc., some programs, such as daemons or those running within an interpreter or virtual machine (where <code>argv[0]</code> would be the name of the host executable), may choose to alter their argv to give a more descriptive <code>argv[0]</code>, usually by means of the <code>exec</code> system call.

The <code>main()</code> function is special; normally every C and C++ program must define it exactly once.

If declared, <code>main()</code> must be declared as if it has external linkage; it cannot be declared <code>static</code> or <code>inline</code>.

In C++, <code>main()</code> must be in the global namespace (i.e. <code>::main</code>), cannot be overloaded, and cannot be a member function, although the name is not otherwise reserved, and may be used for member functions, classes, enumerations, or non-member functions in other namespaces. In C++ (unlike C) <code>main()</code> cannot be called recursively and cannot have its address taken.

===C#===
When executing a program written in C#, the CLR searches for a static method marked with the <code>.entrypoint</code> IL directive, which takes either no arguments, or a single argument of type <code>string[]</code>, and has a return type of <code>void</code> or <code>int</code>, and executes it.

<source lang="csharp">
static void Main();
static void Main(string[] args);
static int Main();
static int Main(string[] args);
</source>

Command-line arguments are passed in <code>args</code>, similar to how it is done in Java. For versions of <code>Main()</code> returning an integer, similar to both C and C++, it is passed back to the environment as the exit status of the process.

Since C#7.1 there are four more possible signatures of the entry point, which allow asynchronous execution in the <code>Main()</code> Method.

<source lang="csharp">
static Task Main()
static Task<int> Main()
static Task Main(string[])
static Task<int> Main(string[])
</source>

The <code>Task</code> and <code>Task&lt;int&gt;</code> types are the asynchronous equivalents of <code>void</code> and <code>int</code>.

===Clean===
Clean is a functional programming language based on graph rewriting. The initial node is named <code>Start</code> and is of type <code>*World -> *World</code> if it "changes" the world or some fixed type if the program only prints the result after reducing <code>Start</code>.

<source lang="haskell">
Start :: *World -> *World
Start world = startIO ...
</source>

Or even simpler

<source lang="haskell">
Start :: String
Start = "Hello, world!"
</source>

One tells the compiler which option to use to generate the executable file.

===Common Lisp===
ANSI Common Lisp does not define a main function; instead, the code is read and evaluated from top to bottom in a source file. However, the following code will emulate a main function.

<source lang="lisp">
(defun hello-main ()
  (format t "Hello World!~%"))

(hello-main)
</source>

===D===
In D, the function prototype of the main function looks like one of the following:

<source lang="D">
void main();
void main(string[] args);
int main();
int main(string[] args);
</source>

Command-line arguments are passed in <code>args</code>, similar to how it is done in C# or Java. For versions of <code>main()</code> returning an integer, similar to both C and C++, it is passed back to the environment as the exit status of the process.

===FORTRAN===
FORTRAN does not have a main subroutine or function. Instead a <code>PROGRAM</code> statement as the first line can be used to specify that a program unit is a main program, as shown below. The <code>PROGRAM</code> statement cannot be used for recursive calls.

<source lang="fortran">
      PROGRAM HELLO
      PRINT *, "Cint!"
      END PROGRAM HELLO
</source>

Some versions of Fortran, such as those on the IBM System/360 and successor mainframes, do not support the PROGRAM statement. Many compilers from other software manufacturers will allow a fortran program to be compiled without a PROGRAM statement. In these cases, whatever module that has any non-comment statement where no SUBROUTINE, FUNCTION or BLOCK DATA statement occurs, is considered to be the Main program.

===GNAT===
Using GNAT, the programmer is not required to write a function named <code>main</code>; a source file containing a single subprogram can be compiled to an executable. The binder will however create a package <code>ada_main</code>, which will contain and export a C-style main function.

===Go===
In Go programming language, program execution starts with the <code>main</code> function of the <code>package main</code>

<source lang="go">
package main

import "fmt"

func main() {
 fmt.Println("Hello, World!")
}
</source>

There is no way to access arguments or a return code outside of the standard library in Go. These can be accessed via <code>os.Args</code> and <code>os.Exit</code> respectively, both of which are included in the <code>"os"</code> package.

===Haskell===
A Haskell program must contain a name <code>main</code> bound to a value of type <code>IO t</code>, for some type <code>t</code>; which is usually <code>IO ()</code>. <code>IO</code> is a monad, which organizes side-effects in terms of purely functional code. The <code>main</code> value represents the side-effects-ful computation done by the program. The result of the computation represented by <code>main</code> is discarded; that is why <code>main</code> usually has type <code>IO ()</code>, which indicates that the type of the result of the computation is <code>()</code>, the unit type, which contains no information.

<source lang="haskell">
main :: IO ()
main = putStrLn "Hello, World!"
</source>

Command line arguments are not given to <code>main</code>; they must be fetched using another IO action, such as <code>[https://downloads.haskell.org/~ghc/latest/docs/html/libraries/base-4.11.1.0/System-Environment.html#v%3AgetArgs System.Environment.getArgs]</code>.

===Java===
Java programs start executing at the main method of a class, which has the following method heading:

<source lang="java5">
public static void main(String[] args)
public static void main(String... args)
public static void main(String args[])
</source>

Command-line arguments are passed in <code>args</code>. As in C and C++, the name "<code>main()</code>" is special. Java's main methods do not return a value directly, but one can be passed by using the <code>System.exit()</code> method.

Unlike C, the name of the program is not included in <code>args</code>, because it is the name of the class that contains the main method, so it is already known. Also unlike C, the number of arguments need not be included, since arrays in Java have a field that keeps track of how many elements there are.

The main function must be included within a class. This is because in Java everything has to be contained within a class. For instance, a hello world program in Java may look like:

<source lang="java5">
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
</source>

To run this program, one must call <code>java HelloWorld</code> in the directory where the compiled class file <code>HelloWorld.class</code>) exists. Alternatively, executable JAR files use a manifest file to specify the entry point in a manner that is filesystem-independent from the user's perspective.

===LOGO===
In FMSLogo, the procedures when loaded do not execute. To make them execute, it is necessary to use this code:

 to procname
  ...                 ; Startup commands (such as print [Welcome])
 end

 make "startup [procname]

The variable <code>startup</code> is used for the startup list of actions, but the convention is that this calls another procedure that runs the actions. That procedure may be of any name.

===OCaml===
OCaml has no <code>main</code> function. Programs are evaluated from top to bottom.

Command-line arguments are available in an array named <code>Sys.argv</code> and the exit status is 0 by default.

Example:
<source lang="ocaml">

print_endline "Hello World"

</source>

===Pascal===
In Pascal, the main procedure is the only unnamed block in the program. Because Pascal programs define procedures and functions in a more rigorous bottom-up order than C, C++ or Java programs, the main procedure is usually the last block in the program. Pascal does not have a special meaning for the name "<code>main</code>" or any similar name.

<source lang="pascal">
program Hello(Output);
begin
  writeln('Hello, world!');
end.
</source>

Command-line arguments are counted in <code>ParamCount</code> and accessible as strings by <code>ParamStr(n)</code>, with n between 0 and <code>ParamCount</code>.

Versions of Pascal that support units or modules may also contain an unnamed block in each, which is used to initialize the module. These blocks are executed before the main program entry point is called.

===Perl===
In Perl, there is no main function. Statements are executed from top to bottom.

Command-line arguments are available in the special array <code>@ARGV</code>. Unlike C, <code>@ARGV</code> does not contain the name of the program, which is <code>$0</code>.

===PHP===
PHP does not have a "main" function. Starting from the first line of a PHP script, any code not encapsulated by a function header is executed as soon as it is seen.

===Pike===
In Pike syntax is similar to that of C and C++.  The execution begins at <code>main</code>.  The "<code>argc</code>" variable keeps the number of arguments passed to the program.  The "<code>argv</code>" variable holds the value associated with the arguments passed to the program.

Example:
<source lang="pike">
 int main(int argc, array(string) argv)
</source>

===Python===
Python programs are evaluated top-to-bottom, as is usual in scripting languages: the entry point is the start of the source code. Since definitions must precede use, programs are typically structured with definitions at the top and the code to execute at the bottom (unindented), similar to code for a one-pass compiler, such as in Pascal.

Alternatively, a program can be structured with an explicit <code>main</code> function containing the code to be executed when a program is executed directly, but which can also be invoked by importing the program as a module and calling the function. This can be done by the following idiom, which relies on the internal variable <code>__name__</code> being set to <code>__main__</code> when a program is executed, but not when it is imported as a module (in which case it is instead set to the module name); there are many variants of this structure:

<source lang="python">
import sys

def main(argv):
    n = int(argv[1])
    print(n + 1)

if __name__ == '__main__':
    sys.exit(main(sys.argv))
</source>

In this idiom, the call to the named entry point <code>main</code> is explicit, and the interaction with the operating system (receiving the arguments, calling system exit) are done explicitly by library calls, which are ultimately handled by the Python runtime. This contrast with C, where these are done "implicitly" by the runtime, based on convention.

=== QB64 ===
The QB64 language has no main function, the code that is not within a function, or subroutine is executed first, from top to bottom:
<syntaxhighlight lang="vb">
print "Hello World! a =";
a = getInteger(1.8d): print a

function getInteger(n as double)
    getInteger = int(n)
end function
</syntaxhighlight>
Command line arguments (if any) can be read using the COMMAND$ function:
<syntaxhighlight lang="vb">
dim shared commandline as string
commandline = COMMAND$

'Several space-separared command line arguments can be read using COMMAND$(n)
commandline1 = COMMAND$(2)
</syntaxhighlight>

===Ruby===
In Ruby, there is no distinct main function. The code written without additional "<code>class .. end</code>", "<code>module .. end</code>" enclosures is executed directly, step by step, in context of special "<code>main</code>" object. This object can be referenced using:

<source lang="irb">
irb(main):001:0> self
=> main
</source>

and contain the following properties:

<source lang="irb">
irb(main):002:0> self.class
=> Object
irb(main):003:0> self.class.ancestors
=> [Object, Kernel, BasicObject]
</source>

Methods defined without additional classes/modules are defined as private methods of the "<code>main</code>" object, and, consequently, as private methods of almost any other object in Ruby:

<source lang="irb">
irb(main):004:0> def foo
irb(main):005:1>   42
irb(main):006:1> end
=> nil
irb(main):007:0> foo
=> 42
irb(main):008:0> [].foo
NoMethodError: private method `foo' called for []:Array
	from (irb):8
	from /usr/bin/irb:12:in `<main>'
irb(main):009:0> false.foo
NoMethodError: private method `foo' called for false:FalseClass
	from (irb):9
	from /usr/bin/irb:12:in `<main>'
</source>

Number and values of command-line arguments can be determined using the single <code>ARGV</code> constant array:

<source lang="console">
$ irb /dev/tty foo bar

tty(main):001:0> ARGV
ARGV
=> ["foo", "bar"]
tty(main):002:0> ARGV.size
ARGV.size
=> 2
</source>

The first element of <code>ARGV</code>, <code>ARGV[0]</code>, contains the first command-line argument, not the name of program executed, as in C. The name of program is available using <code>$0</code> or <code>$PROGRAM_NAME</code>.

Similar to Python, one could use:

<source lang="ruby">
if __FILE__ == $PROGRAM_NAME
  # Put "main" code here
end
</source>

===Rust===
In Rust, the entry point of a program is a function named <code>main</code>. Typically, this function is situated in a file called <code>main.rs</code> or <code>lib.rs</code>.
<source lang="rust">
// In `main.rs`
fn main() {
    println!("Hello, World!");
}
</source>
Additionally, as of Rust 1.26.0, the main function may return a <code>Result</code>:
<source lang="rust">
fn main() -> Result<(), std::io::Error> {
    println!("Hello, World!");

    Ok(())  // Return a type `Result` of value `Ok` with the content `()`, i.e. an empty tuple.
}
</source>

=== Swift ===
When run in an Xcode Playground, Swift behaves like a scripting language, executing statements from top to bottom; top-level code is allowed.<syntaxhighlight lang="swift">
// HelloWorld.playground

let hello = "hello"
let world = "world"

let helloWorld = hello + " " + world

print(helloWorld) // hello world
</syntaxhighlight>Cocoa- and Cocoa Touch-based applications written in Swift are usually initialized with the <code>@NSApplicationMain</code> and <code>@UIApplicationMain</code> attributes, respectively. Those attributes are equivalent in their purpose to the <code>main.m</code> file in Objective-C projects: they implicitly declare the <code>main</code> function that calls <code>UIApplicationMain(_:_:_:_:)</code> which creates an instance of <code>UIApplication</code>.

The following code is the default way to initialize a Cocoa Touch-based iOS app and declare its application delegate.<syntaxhighlight lang="swift">
// AppDelegate.swift

import UIKit

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {
    
    var window: UIWindow?
    
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        return true
    }
    
}
</syntaxhighlight>

===Visual Basic===
In Visual Basic, when a project contains no forms, the startup object may be the <code>Main()</code> procedure. The <code>Command$</code> function can be optionally used to access the argument portion of the command line used to launch the program:
<source lang="vb">
Sub Main()
    Debug.Print "Hello World!"
    MsgBox "Arguments if any are: " & Command$
End Sub
</source>

===Xojo===
In Xojo, there are two different project types, each with a different main entry point. Desktop (GUI) applications start with the <code>App.Open</code> event of the project's <code>Application</code> object. Console applications start with the <code>App.Run</code> event of the project's <code>ConsoleApplication</code> object. In both instances, the main function is automatically generated, and cannot be removed from the project.

== See also ==

* crt0, a set of execution startup routines linked into a C program
* Runtime system

== References ==
== External links ==
* [https://blogs.oracle.com/ksplice/entry/hello_from_a_libc_free Hello from a libc-free world! (Part 1)], March 16, 2010
* [http://www.javaexperience.com/main-method-in-java/ How main method works in Java]
Category:Control flow
Category:Computer programming
Category:.NET programming languages
Category:Software
